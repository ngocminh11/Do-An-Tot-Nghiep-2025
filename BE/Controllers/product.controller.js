const mongoose = require('mongoose');
const slugify = require('slugify');
const ExcelJS = require('exceljs');

const Product = require('../Models/Products');
const ProductDetail = require('../Models/ProductDetail');
const Category = require('../Models/Categories');
const ProductLog = require('../Models/ProductLog');
const Storage = require('../Models/Storage');

const checkPin = require('../Utils/checkPin');          // üîê
const { sendSuccess, sendError } = require('../Utils/responseHelper');
const StatusCodes = require('../Constants/ResponseCode');
const Messages = require('../Constants/ResponseMessage');
require('dotenv').config();

/* -------------------- CONST & HELPER ------------------------------------- */
const ALLOWED_STATUS = ['Hi·ªÉn Th·ªã', '·∫®n', 'Ng·ª´ng B√°n'];
const STATUS_FLOW = {
  'Hi·ªÉn Th·ªã': ['·∫®n', 'Ng·ª´ng B√°n'],
  '·∫®n': ['Hi·ªÉn Th·ªã', 'Ng·ª´ng B√°n'],
  'Ng·ª´ng B√°n': []
};

const isValidId = id => mongoose.Types.ObjectId.isValid(id);
const regex = txt => new RegExp(`^${txt}`, 'i');
const fmtDate = d => new Date(d).toLocaleString('vi-VN', { timeZone: 'Asia/Ho_Chi_Minh' });
const parseJSON = (body, field) => {
  try { return JSON.parse(body[field] || '{}'); }
  catch (e) { throw new Error(`JSON kh√¥ng h·ª£p l·ªá ·ªü "${field}": ${e.message}`); }
};
const buildFilter = ({ name, status, categoryId }) => {
  const f = {};
  if (typeof name === 'string' && name.trim() !== '') f['basicInformation.productName'] = regex(name.trim());
  if (typeof status === 'string' && status.trim() !== '') f['basicInformation.status'] = status.trim();
  if (typeof categoryId === 'string' && categoryId.trim() !== '') f['basicInformation.categoryIds'] = categoryId.trim();
  return f;
};
const logAction = (productId, action, operatorId, payload = {}) =>
  ProductLog.create({ productId, action, operatorId, payload });

// Helper ƒë·ªÉ g·ªôp Product + ProductDetail
const mergeProductAndDetail = (product, detail) => {
  if (!product) return null;
  // ƒê·∫£m b·∫£o _id l√† id c·ªßa Products.js, detailId l√† id c·ªßa ProductDetail.js
  const merged = { ...detail, ...product };
  merged._id = product._id; // lu√¥n l√† id c·ªßa Products.js
  merged.detailId = product.detailId; // lu√¥n l√† id c·ªßa ProductDetail.js
  return merged;
};

// Helper ƒë·ªÉ tr·∫£ v·ªÅ d·∫°ng { product, detail }
const combineProductAndDetail = (product, detail) => {
  if (!product) return null;
  return { product, detail: detail || null };
};

/* ======================================================================== */
/* 1. GET /products                                                         */
/* ======================================================================== */
exports.getAllProducts = async (req, res) => {
  try {
    const { page = 1, limit = 10 } = req.query;
    const filter = buildFilter(req.query);
    const skip = (page - 1) * limit;
    const products = await Product.find({ ...filter, isDeleted: false })
      .sort({ createdAt: -1, updatedAt: -1 })
      .skip(Number(skip)).limit(Number(limit))
      .populate('basicInformation.categoryIds', 'name')
      .populate('basicInformation.tagIds', 'name')
      .lean();
    const ids = products.map(p => p.detailId);
    const details = await ProductDetail.find({ _id: { $in: ids } }).lean();
    console.log('Detail IDs:', ids);
    console.log('Details found:', details);
    const map = Object.fromEntries(details.map(d => [d._id.toString(), d]));
    const combined = products.map(p => combineProductAndDetail(p, map[p.detailId?.toString()] || null));
    return sendSuccess(res, StatusCodes.SUCCESS_OK, {
      data: combined,
      currentPage: +page,
      totalPages: Math.ceil((await Product.countDocuments({ ...filter, isDeleted: false })) / limit),
      totalItems: await Product.countDocuments({ ...filter, isDeleted: false }),
      perPage: +limit
    });
  } catch (err) {
    return sendError(res, StatusCodes.ERROR_INTERNAL_SERVER, err.message);
  }
};

/* ======================================================================== */
/* 2. GET /products/:id                                                     */
/* ======================================================================== */
exports.getProductById = async (req, res) => {
  const { id } = req.params;
  if (!isValidId(id))
    return sendError(res, StatusCodes.ERROR_BAD_REQUEST, Messages.INVALID_ID);
  try {
    const product = await Product.findOne({ _id: id, isDeleted: false })
      .populate('basicInformation.categoryIds', 'name')
      .populate('basicInformation.tagIds', 'name')
      .lean();
    if (!product)
      return sendError(res, StatusCodes.ERROR_NOT_FOUND, Messages.PRODUCT_NOT_FOUND);
    const detail = product.detailId ? await ProductDetail.findOne({ _id: product.detailId, isDeleted: false }).lean() : null;
    return sendSuccess(res, StatusCodes.SUCCESS_OK, combineProductAndDetail(product, detail));
  } catch (e) {
    return sendError(res, StatusCodes.ERROR_INTERNAL_SERVER, e.message);
  }
};

/* ======================================================================== */
/* 3. POST /products  ‚Äì T·∫°o s·∫£n ph·∫©m (üîêCHECK PIN)                          */
/* ======================================================================== */
exports.createProduct = async (req, res) => {
  try {
    // Parse d·ªØ li·ªáu
    const bi = parseJSON(req.body, 'basicInformation');
    const piv = parseJSON(req.body, 'pricingAndInventory');
    const desc = parseJSON(req.body, 'description');
    const tech = parseJSON(req.body, 'technicalDetails');
    const seo = parseJSON(req.body, 'seo');
    const pol = parseJSON(req.body, 'policy');
    const batchCode = req.body.batchCode;
    console.log(req.body, "basicInformation");
    // Validate tr∆∞·ªùng b·∫Øt bu·ªôc
    if (!bi.productName || !bi.sku) {
      return sendError(res, StatusCodes.ERROR_BAD_REQUEST, Messages.PRODUCT_NAME_REQUIRED);
    }
    if (!Array.isArray(bi.tagIds) || bi.tagIds.length === 0) {
      return sendError(res, StatusCodes.ERROR_BAD_REQUEST, 'Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt tag!');
    }
    if (!Array.isArray(bi.categoryIds) || bi.categoryIds.length === 0) {
      return sendError(res, StatusCodes.ERROR_BAD_REQUEST, 'Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt danh m·ª•c!');
    }
    if (!piv || piv.originalPrice == null || piv.salePrice == null || piv.stockQuantity == null || !piv.unit) {
      return sendError(res, StatusCodes.ERROR_BAD_REQUEST, 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin gi√° v√† t·ªìn kho!');
    }
    // Validate ·∫£nh
    if (!req.uploadedImages || req.uploadedImages.length === 0) {
      return sendError(res, StatusCodes.ERROR_BAD_REQUEST, Messages.IMAGE_REQUIRED);
    }
    // S·ª≠a status m·∫∑c ƒë·ªãnh n·∫øu FE g·ª≠i sai
    if (!bi.status || !['Hi·ªÉn Th·ªã', '·∫®n', 'Ng·ª´ng B√°n'].includes(bi.status)) {
      bi.status = 'Hi·ªÉn Th·ªã';
    }
    // ƒê·∫£m b·∫£o tagIds l√† m·∫£ng, kh√¥ng null
    if (!Array.isArray(bi.tagIds)) bi.tagIds = [];
    // ƒê·∫£m b·∫£o categoryIds l√† m·∫£ng
    if (!Array.isArray(bi.categoryIds)) bi.categoryIds = [];
    // X·ª≠ l√Ω technicalDetails: n·∫øu tr∆∞·ªùng n√†o l√† object th√¨ chuy·ªÉn th√†nh chu·ªói r·ªóng
    Object.keys(tech || {}).forEach(key => {
      if (typeof tech[key] === 'object' && tech[key] !== null && !Array.isArray(tech[key])) tech[key] = '';
    });
    // ƒê·∫£m b·∫£o c√°c tr∆∞·ªùng m·∫£ng trong detail l√† m·∫£ng
    if (desc) {
      if (!Array.isArray(desc.features)) desc.features = desc.features ? [desc.features] : [];
      if (!Array.isArray(desc.ingredients)) desc.ingredients = desc.ingredients ? [desc.ingredients] : [];
      if (!Array.isArray(desc.usageInstructions)) desc.usageInstructions = desc.usageInstructions ? [desc.usageInstructions] : [];
    }
    if (tech) {
      if (!Array.isArray(tech.suitableSkinTypes)) tech.suitableSkinTypes = tech.suitableSkinTypes ? [tech.suitableSkinTypes] : [];
      if (!Array.isArray(tech.certifications)) tech.certifications = tech.certifications ? [tech.certifications] : [];
    }
    if (seo) {
      if (!seo.urlSlug || seo.urlSlug.trim() === '') {
        const base = bi.productName || bi.sku || '';
        seo.urlSlug = slugify(base, { lower: true, strict: true });
      }
    }
    if (pol) {
      if (!Array.isArray(pol.shippingReturnWarranty)) pol.shippingReturnWarranty = pol.shippingReturnWarranty ? [pol.shippingReturnWarranty] : [];
      if (!Array.isArray(pol.additionalOptions)) pol.additionalOptions = pol.additionalOptions ? [pol.additionalOptions] : [];
    }
    // X·ª≠ l√Ω file ·∫£nh t·ª´ GridFS (upload.middleware.js)
    let images = [];
    if (req.uploadedImages && req.uploadedImages.length > 0) {
      images = req.uploadedImages.map(file => ({
        _id: file._id,
        filename: file.filename,
        mimetype: file.contentType,
        path: `/admin/media/${file._id}`
      }));
    }
    // T·∫°o _id tr∆∞·ªõc
    const detailId = new mongoose.Types.ObjectId();
    // T·∫°o Product v·ªõi detailId t·∫°m th·ªùi
    const product = new Product({ basicInformation: bi, detailId, isDeleted: false });
    await product.save();
    // T·∫°o ProductDetail v·ªõi _id tr√πng detailId
    const detail = new ProductDetail({
      _id: detailId,
      pricingAndInventory: piv,
      description: desc,
      technicalDetails: tech,
      seo: seo,
      policy: pol,
      batchCode: batchCode,
      mediaFiles: { images },
      isDeleted: false
    });
    await detail.save();
    // G·ªôp tr·∫£ v·ªÅ 1 object
    const merged = mergeProductAndDetail(product.toObject(), detail.toObject());
    return sendSuccess(res, StatusCodes.SUCCESS_CREATED, merged, 'T·∫°o s·∫£n ph·∫©m th√†nh c√¥ng');
  } catch (err) {
    if (err.code === 11000 && err.message.includes('sku')) {
      return sendError(res, StatusCodes.ERROR_BAD_REQUEST, 'SKU_EXISTS');
    }
    if (err.code === 11000 && err.message.includes('urlSlug')) {
      return sendError(res, StatusCodes.ERROR_BAD_REQUEST, 'URLSLUG_EXISTS');
    }
    const code = err.message.includes('PIN') ? StatusCodes.ERROR_UNAUTHORIZED
      : StatusCodes.ERROR_BAD_REQUEST;
    return sendError(res, code, err.message);
  }
};

/* ======================================================================== */
/* 4. PUT /products/:id ‚Äì C·∫≠p nh·∫≠t m√¥ t·∫£ chung (üîê)                         */
/* ======================================================================== */
exports.updateProduct = async (req, res) => {
  const { id } = req.params;
  if (!isValidId(id))
    return sendError(res, StatusCodes.ERROR_BAD_REQUEST, Messages.INVALID_ID);
  try {
    const bi = parseJSON(req.body, 'basicInformation');
    const piv = parseJSON(req.body, 'pricingAndInventory');
    const desc = parseJSON(req.body, 'description');
    const tech = parseJSON(req.body, 'technicalDetails');
    const seo = parseJSON(req.body, 'seo');
    const pol = parseJSON(req.body, 'policy');
    const batchCode = req.body.batchCode;
    // ƒê·∫£m b·∫£o c√°c tr∆∞·ªùng m·∫£ng trong detail l√† m·∫£ng
    if (desc) {
      if (!Array.isArray(desc.features)) desc.features = desc.features ? [desc.features] : [];
      if (!Array.isArray(desc.ingredients)) desc.ingredients = desc.ingredients ? [desc.ingredients] : [];
      if (!Array.isArray(desc.usageInstructions)) desc.usageInstructions = desc.usageInstructions ? [desc.usageInstructions] : [];
    }
    if (tech) {
      if (!Array.isArray(tech.suitableSkinTypes)) tech.suitableSkinTypes = tech.suitableSkinTypes ? [tech.suitableSkinTypes] : [];
      if (!Array.isArray(tech.certifications)) tech.certifications = tech.certifications ? [tech.certifications] : [];
    }
    if (seo) {
      if (!seo.urlSlug || seo.urlSlug.trim() === '') {
        const base = bi.productName || bi.sku || '';
        seo.urlSlug = slugify(base, { lower: true, strict: true });
      }
    }
    if (pol) {
      if (!Array.isArray(pol.shippingReturnWarranty)) pol.shippingReturnWarranty = pol.shippingReturnWarranty ? [pol.shippingReturnWarranty] : [];
      if (!Array.isArray(pol.additionalOptions)) pol.additionalOptions = pol.additionalOptions ? [pol.additionalOptions] : [];
    }
    await Product.findByIdAndUpdate(id, { basicInformation: bi });
    const product = await Product.findOne({ _id: id, isDeleted: false }).lean();
    if (product && product.detailId) {
      await ProductDetail.findByIdAndUpdate(product.detailId, {
        pricingAndInventory: piv,
        description: desc,
        technicalDetails: tech,
        seo: seo,
        policy: pol,
        batchCode: batchCode
      });
    }
    const updatedProduct = await Product.findOne({ _id: id, isDeleted: false })
      .populate('basicInformation.categoryIds', 'name')
      .populate('basicInformation.tagIds', 'name')
      .lean();
    const updatedDetail = product && product.detailId
      ? await ProductDetail.findOne({ _id: product.detailId, isDeleted: false }).lean()
      : null;
    const merged = mergeProductAndDetail(updatedProduct, updatedDetail);
    return sendSuccess(res, StatusCodes.SUCCESS_OK, merged, 'C·∫≠p nh·∫≠t s·∫£n ph·∫©m th√†nh c√¥ng');
  } catch (err) {
    if (err.code === 11000 && err.message.includes('sku')) {
      return sendError(res, StatusCodes.ERROR_BAD_REQUEST, 'SKU_EXISTS');
    }
    if (err.code === 11000 && err.message.includes('urlSlug')) {
      return sendError(res, StatusCodes.ERROR_BAD_REQUEST, 'URLSLUG_EXISTS');
    }
    const code = err.message.includes('PIN') ? StatusCodes.ERROR_UNAUTHORIZED
      : StatusCodes.ERROR_BAD_REQUEST;
    return sendError(res, code, err.message);
  }
};

/* ======================================================================== */
/* 6. PATCH /products/:id/status ‚Äì ƒê·ªïi tr·∫°ng th√°i (üîê)                       */
/* ======================================================================== */
exports.changeStatus = async (req, res) => {
  try {
    await checkPin(req);             // üîê
    delete req.body.pin;
  } catch (e) {
    return sendError(res, StatusCodes.ERROR_UNAUTHORIZED, e.message);
  }
  const { id } = req.params;
  const { status } = req.body;
  if (!isValidId(id))
    return sendError(res, StatusCodes.ERROR_BAD_REQUEST, Messages.INVALID_ID);
  try {
    const product = await Product.findOne({ _id: id, isDeleted: false });
    if (!product) return sendError(res, StatusCodes.ERROR_NOT_FOUND, Messages.PRODUCT_NOT_FOUND);
    const oldStatus = product.basicInformation.status;
    if (oldStatus !== status) {
      product.basicInformation.status = status;
      await product.save();
      await logAction(id, 'STATUS', req.user?._id, { from: oldStatus, to: status });
    }
    return sendSuccess(res, StatusCodes.SUCCESS_OK, product, 'ƒê·ªïi tr·∫°ng th√°i th√†nh c√¥ng');
  } catch (err) {
    return sendError(res, StatusCodes.ERROR_INTERNAL_SERVER, err.message);
  }
};

/* ======================================================================== */
/* 7. DELETE /products/:id  ‚Äì Xo√° s·∫£n ph·∫©m (üîê)                              */
/* ======================================================================== */
exports.deleteProduct = async (req, res) => {
  // KH√îNG c·∫ßn checkPin ·ªü ƒë√¢y n·ªØa
  const { id } = req.params;
  if (!isValidId(id))
    return sendError(res, StatusCodes.ERROR_BAD_REQUEST, Messages.INVALID_ID);
  try {
    const product = await Product.findOne({ _id: id, isDeleted: false }).lean();
    if (!product) return sendError(res, StatusCodes.ERROR_NOT_FOUND, Messages.PRODUCT_NOT_FOUND);
    const detail = product.detailId ? await ProductDetail.findOne({ _id: product.detailId, isDeleted: false }).lean() : null;
    // X√≥a m·ªÅm: c·∫≠p nh·∫≠t isDeleted=true
    await Product.updateOne({ _id: id }, { isDeleted: true });
    if (product.detailId) await ProductDetail.updateOne({ _id: product.detailId }, { isDeleted: true });
    const merged = mergeProductAndDetail(product, detail);
    await logAction(id, 'DELETE', req.user?._id, { product, detail });
    return sendSuccess(res, StatusCodes.SUCCESS_OK, merged, 'X√≥a s·∫£n ph·∫©m th√†nh c√¥ng');
  } catch (err) {
    return sendError(res, StatusCodes.ERROR_INTERNAL_SERVER, err.message);
  }
};

// ===== 8. GET /products/export/csv ===========================================
exports.exportProductsToExcel = async (req, res) => {
  try {
    const filter = buildFilter(req.query);
    const products = await Product.find({ ...filter, isDeleted: false })
      .populate('basicInformation.categoryIds', 'name')
      .sort({ updatedAt: -1 })
      .lean();
    if (!products.length)
      return sendError(res, StatusCodes.ERROR_NOT_FOUND, 'Kh√¥ng c√≥ s·∫£n ph·∫©m n√†o');

    const ids = products.map(p => p._id);
    const details = await ProductDetail.find({ _id: { $in: ids }, isDeleted: false }, 'pricingAndInventory description technicalDetails').lean();
    const map = Object.fromEntries(details.map(d => [d._id.toString(), d]));

    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Products');
    ws.columns = [
      { header: 'T√™n SP', key: 'name', width: 30 },
      { header: 'SKU', key: 'sku', width: 18 },
      { header: 'Tr·∫°ng th√°i', key: 'status', width: 12 },
      { header: 'Gi√° b√°n', key: 'salePrice', width: 15 },
      { header: 'Kho', key: 'stock', width: 10 },
      { header: 'Ng√†y t·∫°o', key: 'created', width: 18 }
    ];

    products.forEach(p => {
      const d = map[p._id.toString()] || {};
      ws.addRow({
        name: p.basicInformation.productName,
        sku: p.basicInformation.sku,
        status: p.basicInformation.status,
        salePrice: d.pricingAndInventory?.salePrice ?? '',
        stock: d.pricingAndInventory?.stockQuantity ?? '',
        created: fmtDate(p.createdAt)
      });
    });

    const buffer = await wb.xlsx.writeBuffer();
    res.setHeader('Content-Disposition', 'attachment; filename="products.xlsx"');
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    return res.status(200).send(buffer);
  } catch (err) {
    return sendError(res, StatusCodes.ERROR_INTERNAL_SERVER, err.message);
  }
};

// ===== 9. GET /products/category/:id =========================================
exports.getProductsByCategory = async (req, res) => {
  const { categoryId } = req.params;
  const { page = 1, limit = 10, status } = req.query;

  if (!isValidId(categoryId))
    return sendError(res, StatusCodes.ERROR_BAD_REQUEST, Messages.INVALID_ID);

  // ki·ªÉm tra t·ªìn t·∫°i danh m·ª•c
  const category = await Category.findById(categoryId);
  if (!category)
    return sendError(res, StatusCodes.ERROR_NOT_FOUND, Messages.CATEGORY_NOT_FOUND);

  // query
  const q = { 'basicInformation.categoryIds': categoryId };
  if (status) q['basicInformation.status'] = status;

  try {
    const skip = (page - 1) * limit;
    const products = await Product.find({ ...q, isDeleted: false })
      .populate('basicInformation.categoryIds', 'name')
      .populate('basicInformation.tagIds', 'name')
      .sort({ updatedAt: -1 })
      .skip(Number(skip))
      .limit(Number(limit))
      .lean();
    const ids = products.map(p => p.detailId);
    const details = await ProductDetail.find({ _id: { $in: ids }, isDeleted: false }).lean();
    const map = Object.fromEntries(details.map(d => [d._id.toString(), d]));
    const combined = products.map(p => combineProductAndDetail(p, map[p.detailId?.toString()] || null));

    return sendSuccess(res, StatusCodes.SUCCESS_OK, {
      data: combined,
      currentPage: Number(page),
      totalPages: Math.ceil((await Product.countDocuments({ ...q, isDeleted: false })) / limit),
      totalItems: await Product.countDocuments({ ...q, isDeleted: false }),
      perPage: Number(limit),
      category: {
        id: category._id,
        name: category.name,
        description: category.description
      }
    });
  } catch (err) {
    return sendError(res, StatusCodes.ERROR_INTERNAL_SERVER, err.message);
  }
};

// ===== 10. GET /products/:id/logs (c√≥ ph√¢n trang) =============================
exports.getProductLogs = async (req, res) => {
  const { id } = req.params;
  const { page = 1, limit = 20 } = req.query;   // ‚¨ÖÔ∏è  m·∫∑c ƒë·ªãnh 20 log / trang
  const skip = (page - 1) * limit;

  if (!isValidId(id)) {
    return sendError(res, StatusCodes.ERROR_BAD_REQUEST, Messages.INVALID_ID);
  }

  try {
    const [logs, total] = await Promise.all([
      ProductLog.find({ productId: id, isDeleted: false })
        .populate('operatorId', 'name email')      // th√¥ng tin ng∆∞·ªùi thao t√°c (tu·ª≥ user‚Äëmodel)
        .sort({ createdAt: -1 })                   // m·ªõi nh·∫•t tr∆∞·ªõc
        .skip(Number(skip))
        .limit(Number(limit))
        .lean(),
      ProductLog.countDocuments({ productId: id, isDeleted: false })
    ]);

    return sendSuccess(res, StatusCodes.SUCCESS_OK, {
      data: logs,
      totalItems: total,
      currentPage: Number(page),
      totalPages: Math.ceil(total / limit),
      perPage: Number(limit)
    });
  } catch (err) {
    return sendError(res, StatusCodes.ERROR_INTERNAL_SERVER, err.message);
  }
};

// ===== 11. GET /products/logs/all ===========================================
exports.getAllProductLogs = async (req, res) => {
  const { page = 1, limit = 20 } = req.query;
  const skip = (page - 1) * limit;

  try {
    const [logs, total] = await Promise.all([
      ProductLog.find({ isDeleted: false })
        .populate('operatorId', 'name email') // ng∆∞·ªùi thao t√°c
        .populate('productId', 'basicInformation.productName') // t√™n s·∫£n ph·∫©m
        .sort({ createdAt: -1 })
        .skip(Number(skip))
        .limit(Number(limit))
        .lean(),
      ProductLog.countDocuments({ isDeleted: false })
    ]);

    return sendSuccess(res, StatusCodes.SUCCESS_OK, {
      data: logs,
      totalItems: total,
      currentPage: Number(page),
      totalPages: Math.ceil(total / limit),
      perPage: Number(limit)
    });
  } catch (err) {
    return sendError(res, StatusCodes.ERROR_INTERNAL_SERVER, err.message);
  }
};

// 12. BULK IMPORT INVENTORY (NH·∫¨P KHO NHI·ªÄU S·∫¢N PH·∫®M)
exports.bulkImportInventory = async (req, res) => {
  try {
    // L·∫•y th√¥ng tin phi·∫øu nh·∫≠p
    const {
      billCode, billDate, createdBy, receivedBy, supplier, supplierCode, supplierAddress, supplierPhone, supplierEmail,
      poNumber, paymentMethod, shippingFee, discount, vat, note,
      products = [], totalBeforeDiscount, totalDiscount, totalAfterDiscount, totalVAT, totalFinal
    } = req.body;
    if (!Array.isArray(products) || products.length === 0) {
      return sendError(res, StatusCodes.ERROR_BAD_REQUEST, 'Danh s√°ch s·∫£n ph·∫©m nh·∫≠p kho kh√¥ng h·ª£p l·ªá!');
    }
    // Duy·ªát t·ª´ng s·∫£n ph·∫©m ƒë·ªÉ c·∫≠p nh·∫≠t t·ªìn kho
    const results = [];
    for (const p of products) {
      const { productId, quantity, originalPrice, batchCode, mfgDate, expDate, note: productNote } = p;
      if (!isValidId(productId)) continue;
      // C·∫≠p nh·∫≠t t·ªìn kho v√† gi√° nh·∫≠p
      let detail = await ProductDetail.findOne({ _id: productId, isDeleted: false });
      if (!detail) {
        const product = await Product.findOne({ _id: productId, isDeleted: false });
        if (product && product.detailId) {
          detail = await ProductDetail.findOne({ _id: product.detailId, isDeleted: false });
        }
      }
      if (!detail) continue;
      // L∆∞u gi√° v√† t·ªìn kho c≈© ƒë·ªÉ log
      const oldStock = detail.pricingAndInventory.stockQuantity || 0;
      const oldPrice = detail.pricingAndInventory.originalPrice || 0;
      // C·ªòNG D·ªíN s·ªë l∆∞·ª£ng nh·∫≠p v√†o t·ªìn kho hi·ªán c√≥
      if (typeof quantity === 'number' && quantity > 0) {
        detail.pricingAndInventory.stockQuantity = oldStock + quantity;
      }
      // C·∫≠p nh·∫≠t gi√° nh·∫≠p m·ªõi n·∫øu c√≥
      if (typeof originalPrice === 'number' && originalPrice >= 0) {
        detail.pricingAndInventory.originalPrice = originalPrice;
      }
      // C·∫≠p nh·∫≠t batchCode, NSX, HSD, note n·∫øu c√≥
      if (batchCode) detail.batchCode = batchCode;
      if (mfgDate) detail.mfgDate = mfgDate;
      if (expDate) detail.expDate = expDate;
      if (productNote) detail.note = productNote;
      await detail.save();
      // Log thao t√°c nh·∫≠p kho (phi·∫øu)
      await logAction(productId, 'Nh·∫≠p kho (phi·∫øu)', req.user?._id, {
        quantity, originalPrice, batchCode, mfgDate, expDate, productNote,
        billCode, billDate, createdBy, receivedBy, supplier, supplierCode, supplierAddress, supplierPhone, supplierEmail,
        poNumber, paymentMethod, shippingFee, discount, vat, note,
        totalBeforeDiscount, totalDiscount, totalAfterDiscount, totalVAT, totalFinal
      });
      // Log nh·∫≠p kho t·ª´ng s·∫£n ph·∫©m
      await logAction(productId, 'IMPORT', req.user?._id, {
        quantity, originalPrice, batchCode, mfgDate, expDate, productNote
      });
      // N·∫øu t·ªìn kho thay ƒë·ªïi, log UPDATE_STOCK
      if (typeof quantity === 'number' && quantity > 0) {
        await logAction(productId, 'UPDATE_STOCK', req.user?._id, { from: oldStock, to: detail.pricingAndInventory.stockQuantity });
      }
      // N·∫øu gi√° thay ƒë·ªïi, log UPDATE_PRICE
      if (typeof originalPrice === 'number' && originalPrice !== oldPrice) {
        await logAction(productId, 'UPDATE_PRICE', req.user?._id, { from: oldPrice, to: originalPrice });
      }
      results.push({ productId, success: true });
    }
    // C√≥ th·ªÉ l∆∞u th√™m 1 collection ri√™ng cho phi·∫øu nh·∫≠p n·∫øu mu·ªën (ch∆∞a l√†m ·ªü ƒë√¢y)
    return sendSuccess(res, StatusCodes.SUCCESS_OK, { results }, 'Nh·∫≠p kho h√†ng lo·∫°t th√†nh c√¥ng');
  } catch (err) {
    return sendError(res, StatusCodes.ERROR_INTERNAL_SERVER, err.message);
  }
};

// DUY·ªÜT PHI·∫æU NH·∫¨P KHO
exports.approveImportInventory = async (req, res) => {
  try {
    const { storageId } = req.body;
    if (!isValidId(storageId)) return sendError(res, StatusCodes.ERROR_BAD_REQUEST, 'ID phi·∫øu nh·∫≠p kho kh√¥ng h·ª£p l·ªá!');
    const storage = await Storage.findById(storageId);
    if (!storage) return sendError(res, StatusCodes.ERROR_NOT_FOUND, 'Kh√¥ng t√¨m th·∫•y phi·∫øu nh·∫≠p kho!');
    if (storage.status === 'ƒê√£ Duy·ªát') return sendError(res, StatusCodes.ERROR_BAD_REQUEST, 'Phi·∫øu ƒë√£ ƒë∆∞·ª£c duy·ªát!');
    // C·ªông t·ªìn kho v√†o ProductDetail
    const detail = await ProductDetail.findById(storage.productDetail);
    if (!detail) return sendError(res, StatusCodes.ERROR_NOT_FOUND, 'Kh√¥ng t√¨m th·∫•y chi ti·∫øt s·∫£n ph·∫©m!');
    const oldStock = detail.pricingAndInventory.stockQuantity || 0;
    detail.pricingAndInventory.stockQuantity = oldStock + storage.quantity;
    await detail.save();
    // ƒê√°nh d·∫•u ƒë√£ duy·ªát
    storage.status = 'ƒê√£ Duy·ªát';
    await storage.save();
    // Log thao t√°c
    await logAction(storage.product, 'APPROVE_IMPORT', req.user?._id, { storageId, quantity: storage.quantity });
    await logAction(storage.product, 'UPDATE_STOCK', req.user?._id, { from: oldStock, to: detail.pricingAndInventory.stockQuantity });
    return sendSuccess(res, StatusCodes.SUCCESS_OK, { storageId }, 'Duy·ªát phi·∫øu nh·∫≠p kho th√†nh c√¥ng');
  } catch (err) {
    return sendError(res, StatusCodes.ERROR_INTERNAL_SERVER, err.message);
  }
};

// L·∫§Y DANH S√ÅCH PHI·∫æU NH·∫¨P KHO (STORAGE)
exports.getAllImportStorage = async (req, res) => {
  try {
    const { page = 1, limit = 20, status } = req.query;
    const skip = (page - 1) * limit;
    const filter = { type: 'import' };
    if (status) filter.status = status;
    const [storages, total] = await Promise.all([
      Storage.find(filter)
        .populate('product', 'basicInformation')
        .populate('productDetail', 'pricingAndInventory')
        .populate('category', 'name')
        .sort({ createdAt: -1 })
        .skip(Number(skip))
        .limit(Number(limit))
        .lean(),
      Storage.countDocuments(filter)
    ]);
    return sendSuccess(res, StatusCodes.SUCCESS_OK, {
      data: storages,
      totalItems: total,
      currentPage: Number(page),
      totalPages: Math.ceil(total / limit),
      perPage: Number(limit)
    });
  } catch (err) {
    return sendError(res, StatusCodes.ERROR_INTERNAL_SERVER, err.message);
  }
};
